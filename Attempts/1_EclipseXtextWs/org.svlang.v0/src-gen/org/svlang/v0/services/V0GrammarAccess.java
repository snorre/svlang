/*
* generated by Xtext
*/
package org.svlang.v0.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class V0GrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DomainmodelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Domainmodel");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsRootElementParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//Domainmodel:
		//	elements+=RootElement*;
		public ParserRule getRule() { return rule; }

		//elements+=RootElement*
		public Assignment getElementsAssignment() { return cElementsAssignment; }

		//RootElement
		public RuleCall getElementsRootElementParserRuleCall_0() { return cElementsRootElementParserRuleCall_0; }
	}

	public class RootElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RootElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMainAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMainMainParserRuleCall_0_0 = (RuleCall)cMainAssignment_0.eContents().get(0);
		private final Assignment cFunsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunsFunParserRuleCall_1_0 = (RuleCall)cFunsAssignment_1.eContents().get(0);
		
		//RootElement:
		//	main=Main funs+=Fun*;
		public ParserRule getRule() { return rule; }

		//main=Main funs+=Fun*
		public Group getGroup() { return cGroup; }

		//main=Main
		public Assignment getMainAssignment_0() { return cMainAssignment_0; }

		//Main
		public RuleCall getMainMainParserRuleCall_0_0() { return cMainMainParserRuleCall_0_0; }

		//funs+=Fun*
		public Assignment getFunsAssignment_1() { return cFunsAssignment_1; }

		//Fun
		public RuleCall getFunsFunParserRuleCall_1_0() { return cFunsFunParserRuleCall_1_0; }
	}

	public class MainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Main");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Main:
		//	"main {" expressions+=Expression+ "}";
		public ParserRule getRule() { return rule; }

		//"main {" expressions+=Expression+ "}"
		public Group getGroup() { return cGroup; }

		//"main {"
		public Keyword getMainKeyword_0() { return cMainKeyword_0; }

		//expressions+=Expression+
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_0() { return cExpressionsExpressionParserRuleCall_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class FunElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Fun");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFunKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cReturnTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cReturnTypeTypeCrossReference_4_0 = (CrossReference)cReturnTypeAssignment_4.eContents().get(0);
		private final RuleCall cReturnTypeTypeIDTerminalRuleCall_4_0_1 = (RuleCall)cReturnTypeTypeCrossReference_4_0.eContents().get(1);
		private final Keyword cSpaceLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cExpressionsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cExpressionsExpressionParserRuleCall_6_0 = (RuleCall)cExpressionsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Fun:
		//	{Fun} "fun " name=ID ":" returnType=[Type] " {" expressions+=Expression* "}";
		public ParserRule getRule() { return rule; }

		//{Fun} "fun " name=ID ":" returnType=[Type] " {" expressions+=Expression* "}"
		public Group getGroup() { return cGroup; }

		//{Fun}
		public Action getFunAction_0() { return cFunAction_0; }

		//"fun "
		public Keyword getFunKeyword_1() { return cFunKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//returnType=[Type]
		public Assignment getReturnTypeAssignment_4() { return cReturnTypeAssignment_4; }

		//[Type]
		public CrossReference getReturnTypeTypeCrossReference_4_0() { return cReturnTypeTypeCrossReference_4_0; }

		//ID
		public RuleCall getReturnTypeTypeIDTerminalRuleCall_4_0_1() { return cReturnTypeTypeIDTerminalRuleCall_4_0_1; }

		//" {"
		public Keyword getSpaceLeftCurlyBracketKeyword_5() { return cSpaceLeftCurlyBracketKeyword_5; }

		//expressions+=Expression*
		public Assignment getExpressionsAssignment_6() { return cExpressionsAssignment_6; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_6_0() { return cExpressionsExpressionParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cAssignmentParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////	| FunCall 
		////	| Println
		//Expression:
		//	Assignment;
		public ParserRule getRule() { return rule; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall() { return cAssignmentParserRuleCall; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAssignmentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeTypeCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeTypeIDTerminalRuleCall_1_0_1 = (RuleCall)cTypeTypeCrossReference_1_0.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cSpaceEqualsSignSpaceKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueAtomicParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		
		//Assignment returns Symbol:
		//	{Assignment} type=[Type] name=ID " = " value=Atomic;
		public ParserRule getRule() { return rule; }

		//{Assignment} type=[Type] name=ID " = " value=Atomic
		public Group getGroup() { return cGroup; }

		//{Assignment}
		public Action getAssignmentAction_0() { return cAssignmentAction_0; }

		//type=[Type]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//[Type]
		public CrossReference getTypeTypeCrossReference_1_0() { return cTypeTypeCrossReference_1_0; }

		//ID
		public RuleCall getTypeTypeIDTerminalRuleCall_1_0_1() { return cTypeTypeIDTerminalRuleCall_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//" = "
		public Keyword getSpaceEqualsSignSpaceKeyword_3() { return cSpaceEqualsSignSpaceKeyword_3; }

		//value=Atomic
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//Atomic
		public RuleCall getValueAtomicParserRuleCall_4_0() { return cValueAtomicParserRuleCall_4_0; }
	}

	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSymbolRefAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cSymbolAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cSymbolSymbolCrossReference_0_1_0 = (CrossReference)cSymbolAssignment_0_1.eContents().get(0);
		private final RuleCall cSymbolSymbolIDTerminalRuleCall_0_1_0_1 = (RuleCall)cSymbolSymbolCrossReference_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumberLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cStringLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cFunCallAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cFunAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cFunFunCrossReference_3_1_0 = (CrossReference)cFunAssignment_3_1.eContents().get(0);
		private final RuleCall cFunFunIDTerminalRuleCall_3_1_0_1 = (RuleCall)cFunFunCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		////Println:
		////	'pln(' (values += Type)+ ')'
		////;
		//Atomic:
		//	{SymbolRef} symbol=[Symbol] | {NumberLiteral} value=INT | {StringLiteral} value=STRING | {FunCall} fun=[Fun] "()";
		public ParserRule getRule() { return rule; }

		//{SymbolRef} symbol=[Symbol] | {NumberLiteral} value=INT | {StringLiteral} value=STRING | {FunCall} fun=[Fun] "()"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{SymbolRef} symbol=[Symbol]
		public Group getGroup_0() { return cGroup_0; }

		//{SymbolRef}
		public Action getSymbolRefAction_0_0() { return cSymbolRefAction_0_0; }

		//symbol=[Symbol]
		public Assignment getSymbolAssignment_0_1() { return cSymbolAssignment_0_1; }

		//[Symbol]
		public CrossReference getSymbolSymbolCrossReference_0_1_0() { return cSymbolSymbolCrossReference_0_1_0; }

		//ID
		public RuleCall getSymbolSymbolIDTerminalRuleCall_0_1_0_1() { return cSymbolSymbolIDTerminalRuleCall_0_1_0_1; }

		//{NumberLiteral} value=INT
		public Group getGroup_1() { return cGroup_1; }

		//{NumberLiteral}
		public Action getNumberLiteralAction_1_0() { return cNumberLiteralAction_1_0; }

		//value=INT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_1_0() { return cValueINTTerminalRuleCall_1_1_0; }

		//{StringLiteral} value=STRING
		public Group getGroup_2() { return cGroup_2; }

		//{StringLiteral}
		public Action getStringLiteralAction_2_0() { return cStringLiteralAction_2_0; }

		//value=STRING
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_1_0() { return cValueSTRINGTerminalRuleCall_2_1_0; }

		//{FunCall} fun=[Fun] "()"
		public Group getGroup_3() { return cGroup_3; }

		//{FunCall}
		public Action getFunCallAction_3_0() { return cFunCallAction_3_0; }

		//fun=[Fun]
		public Assignment getFunAssignment_3_1() { return cFunAssignment_3_1; }

		//[Fun]
		public CrossReference getFunFunCrossReference_3_1_0() { return cFunFunCrossReference_3_1_0; }

		//ID
		public RuleCall getFunFunIDTerminalRuleCall_3_1_0_1() { return cFunFunIDTerminalRuleCall_3_1_0_1; }

		//"()"
		public Keyword getLeftParenthesisRightParenthesisKeyword_3_2() { return cLeftParenthesisRightParenthesisKeyword_3_2; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMyIntTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMyStringTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////FunCall returns Atomic:
		////	name=ID '(' (parameters += Atomic)* ')'
		////;
		//Type:
		//	MyIntType | MyStringType;
		public ParserRule getRule() { return rule; }

		//MyIntType | MyStringType
		public Alternatives getAlternatives() { return cAlternatives; }

		//MyIntType
		public RuleCall getMyIntTypeParserRuleCall_0() { return cMyIntTypeParserRuleCall_0; }

		//MyStringType
		public RuleCall getMyStringTypeParserRuleCall_1() { return cMyStringTypeParserRuleCall_1; }
	}

	public class MyIntTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyIntType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cINTAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIntKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//MyIntType:
		//	{INT} "int";
		public ParserRule getRule() { return rule; }

		//{INT} "int"
		public Group getGroup() { return cGroup; }

		//{INT}
		public Action getINTAction_0() { return cINTAction_0; }

		//"int"
		public Keyword getIntKeyword_1() { return cIntKeyword_1; }
	}

	public class MyStringTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyStringType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSTRINGAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStringKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//MyStringType:
		//	{STRING} "string";
		public ParserRule getRule() { return rule; }

		//{STRING} "string"
		public Group getGroup() { return cGroup; }

		//{STRING}
		public Action getSTRINGAction_0() { return cSTRINGAction_0; }

		//"string"
		public Keyword getStringKeyword_1() { return cStringKeyword_1; }
	}
	
	
	private DomainmodelElements pDomainmodel;
	private RootElementElements pRootElement;
	private MainElements pMain;
	private FunElements pFun;
	private ExpressionElements pExpression;
	private AssignmentElements pAssignment;
	private AtomicElements pAtomic;
	private TypeElements pType;
	private MyIntTypeElements pMyIntType;
	private MyStringTypeElements pMyStringType;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public V0GrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.svlang.v0.V0".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Domainmodel:
	//	elements+=RootElement*;
	public DomainmodelElements getDomainmodelAccess() {
		return (pDomainmodel != null) ? pDomainmodel : (pDomainmodel = new DomainmodelElements());
	}
	
	public ParserRule getDomainmodelRule() {
		return getDomainmodelAccess().getRule();
	}

	//RootElement:
	//	main=Main funs+=Fun*;
	public RootElementElements getRootElementAccess() {
		return (pRootElement != null) ? pRootElement : (pRootElement = new RootElementElements());
	}
	
	public ParserRule getRootElementRule() {
		return getRootElementAccess().getRule();
	}

	//Main:
	//	"main {" expressions+=Expression+ "}";
	public MainElements getMainAccess() {
		return (pMain != null) ? pMain : (pMain = new MainElements());
	}
	
	public ParserRule getMainRule() {
		return getMainAccess().getRule();
	}

	//Fun:
	//	{Fun} "fun " name=ID ":" returnType=[Type] " {" expressions+=Expression* "}";
	public FunElements getFunAccess() {
		return (pFun != null) ? pFun : (pFun = new FunElements());
	}
	
	public ParserRule getFunRule() {
		return getFunAccess().getRule();
	}

	////	| FunCall 
	////	| Println
	//Expression:
	//	Assignment;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//Assignment returns Symbol:
	//	{Assignment} type=[Type] name=ID " = " value=Atomic;
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	////Println:
	////	'pln(' (values += Type)+ ')'
	////;
	//Atomic:
	//	{SymbolRef} symbol=[Symbol] | {NumberLiteral} value=INT | {StringLiteral} value=STRING | {FunCall} fun=[Fun] "()";
	public AtomicElements getAtomicAccess() {
		return (pAtomic != null) ? pAtomic : (pAtomic = new AtomicElements());
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}

	////FunCall returns Atomic:
	////	name=ID '(' (parameters += Atomic)* ')'
	////;
	//Type:
	//	MyIntType | MyStringType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//MyIntType:
	//	{INT} "int";
	public MyIntTypeElements getMyIntTypeAccess() {
		return (pMyIntType != null) ? pMyIntType : (pMyIntType = new MyIntTypeElements());
	}
	
	public ParserRule getMyIntTypeRule() {
		return getMyIntTypeAccess().getRule();
	}

	//MyStringType:
	//	{STRING} "string";
	public MyStringTypeElements getMyStringTypeAccess() {
		return (pMyStringType != null) ? pMyStringType : (pMyStringType = new MyStringTypeElements());
	}
	
	public ParserRule getMyStringTypeRule() {
		return getMyStringTypeAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
